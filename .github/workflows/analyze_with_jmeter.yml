name: Patch & Run Tests

on:
  workflow_dispatch:

jobs:
  classify-and-patch:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Compose
        uses: docker/setup-compose-action@v1

      - name: Pull JDK
        run: docker pull openjdk:17-jdk-slim

      - name: Set up Git
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"

      - name: Write .env file with secrets
        working-directory: ms-example-usage
        run: |
          echo "R2DBC_URL=${{ secrets.AZURE_DB_URI_R2DBC }}" >> .env
          echo "R2DBC_USERNAME=${{ secrets.AZURE_DB_USER }}" >> .env
          echo "R2DBC_PASSWORD=${{ secrets.AZURE_DB_PASSWORD }}" >> .env

      - name: Fetch Vulnerabilities
        id: fetch_vulnerabilities
        env:
          API_TOKEN: ${{ secrets.API_TOKEN_GH }}
        run: |
          QUERY=$(cat <<'EOF'
          {
            "query": "query ($org: String = \"\", $repo: String! = \"\") { organization(login: $org) { repository(name: $repo) { name vulnerabilityAlerts(first: 100, states: OPEN) { nodes { dependencyRelationship vulnerableManifestPath securityVulnerability { advisory { ghsaId summary } severity package { name ecosystem } firstPatchedVersion { identifier } vulnerableVersionRange } } } } } }",
            "variables": {
              "org": "${{ github.repository_owner }}",
              "repo": "${{ github.event.repository.name }}"
            }
          }
          EOF
          )
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $API_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$QUERY" \
            https://api.github.com/graphql)
          echo "$RESPONSE" > vulnerabilities.json
          echo "$RESPONSE" | jq -c '.data.organization.repository.vulnerabilityAlerts.nodes[]' > vulnerabilities_list.json

      - name: Classify Vulnerable Dependencies in library subproject
        working-directory: library-example
        run: |
          gradle dependencies > gradle_dependencies.txt
          gradle buildEnvironment > gradle_build_env.txt

          touch found_in_dependencies.txt
          touch found_in_build_env.txt

          jq -c '.' ../vulnerabilities_list.json | while read -r vuln; do
            PACKAGE=$(echo "$vuln" | jq -r '.securityVulnerability.package.name')
            if grep -q "$PACKAGE" gradle_dependencies.txt; then
              echo "$vuln" >> found_in_dependencies.txt
            fi
            if grep -q "$PACKAGE" gradle_build_env.txt; then
              echo "$vuln" >> found_in_build_env.txt
            fi
          done

      - name: Patch Vulnerable Dependencies in library subproject
        working-directory: library-example
        run: |
          patch_gradle() {
            local GROUP=$1
            local ARTIFACT=$2
            local VERSION=$3
          
            if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
              echo "WARNING: No patched version found for ${GROUP}:${ARTIFACT}, skipping..."
              return 1
            fi
          
            local PATCH_LINE="force '${GROUP}:${ARTIFACT}:${VERSION}'"
            local DIRECT_DEP_REGEX="['\"]${GROUP}:${ARTIFACT}:[^'\"]*['\"]"
            local NEW_DEP="'${GROUP}:${ARTIFACT}:${VERSION}'"
          
            if grep -qE "$DIRECT_DEP_REGEX" build.gradle; then
              echo "→ Updating direct dependency for ${GROUP}:${ARTIFACT} in dependencies block"
              sed -i -E "s|$DIRECT_DEP_REGEX|$NEW_DEP|g" build.gradle
              echo "✓ Patched as direct dependency only"
              return 0
            fi
          
            echo "→ ${GROUP}:${ARTIFACT} not found directly, patching via resolutionStrategy.force"
          
            if grep -q "configurations.all[[:space:]]*{" build.gradle; then
              if grep -A 10 "configurations.all[[:space:]]*{" build.gradle | grep -q "resolutionStrategy[[:space:]]*{"; then
                if grep -q "force[[:space:]]*'${GROUP}:${ARTIFACT}:" build.gradle; then
                  sed -i "s|force[[:space:]]*'${GROUP}:${ARTIFACT}:[^']*'|${PATCH_LINE}|g" build.gradle
                else
                  awk -v patch="$PATCH_LINE" '
                    /resolutionStrategy[[:space:]]*{/ { print; in_block=1; next }
                    in_block && /^\s*}/ { print "        " patch; in_block=0 }
                    { print }
                  ' build.gradle > tmp && mv tmp build.gradle
                fi
              else
                awk -v patch="$PATCH_LINE" '
                  /configurations.all[[:space:]]*{/ {
                    print; print "    resolutionStrategy {"; print "        " patch; print "    }"; next
                  }
                  { print }
                ' build.gradle > tmp && mv tmp build.gradle
              fi
            else
              awk -v patch="$PATCH_LINE" '
                /^dependencies[[:space:]]*{/ {
                  print "configurations.all {";
                  print "    resolutionStrategy {";
                  print "        " patch;
                  print "    }";
                  print "}"; print ""; print $0; next;
                }
                { print }
              ' build.gradle > tmp && mv tmp build.gradle
            fi
          }

          for FILE in found_in_dependencies.txt found_in_build_env.txt; do
            if [ -f "$FILE" ]; then
              while read -r entry; do
                PACKAGE=$(echo "$entry" | jq -r '.securityVulnerability.package.name')
                PATCHED_VERSION=$(echo "$entry" | jq -r '.securityVulnerability.firstPatchedVersion.identifier')
                GROUP=$(echo "$PACKAGE" | cut -d':' -f1)
                ARTIFACT=$(echo "$PACKAGE" | cut -d':' -f2)

                echo "Patching ${GROUP}:${ARTIFACT} to version ${PATCHED_VERSION}"
                patch_gradle "$GROUP" "$ARTIFACT" "$PATCHED_VERSION"
              done < "$FILE"
            fi
          done
      - name: Build with Gradle
        run: export $(grep -v '^#' ms-example-usage/.env | xargs) && ./gradlew :ms-example-usage:build

      - name: All tests passed
        if: success()
        run: echo "✅ All tests passed!"

      - name: Build failed
        if: failure()
        run: echo "❌ Build or tests failed"

      - name: Create Patch Branch, Commit & Push
        run: |
          BRANCH_NAME="patch/vulnerable-dependencies-$(date +%s)"
          git checkout -b "$BRANCH_NAME"
          git add library-example/build.gradle
          git commit -m "Patch vulnerable dependencies"
          git push origin "$BRANCH_NAME"
      - name: Show Final build.gradle (library)
        working-directory: library-example
        run: cat build.gradle

      - name: Run docker compose with logs
        working-directory: ms-example-usage
        run: |
          docker compose up -d
          docker compose logs -f example-app &  # Keep logs streaming

      - name: Wait for service readiness
        run: |
          echo "Waiting for service to start..."
          timeout 120 bash -c 'while ! curl -sSf http://localhost:8080/api/v1/customers >/dev/null; do 
            sleep 5
            docker compose ps
            docker compose logs --tail=20 your-service
          done'

      - name: Check container networking
        run: |
          docker compose exec your-service netstat -tulpn | grep 8080
          # Should show: tcp6 0 0 :::8080 :::* LISTEN   

      - name: Verify port accessibility
        run: |
          netstat -tulpn | grep 8080
          curl -v http://localhost:8080/api/v1/customers
          
          docker run --network container:$(docker compose ps -q your-service) appropriate/curl \
            -v http://localhost:8080/api/v1/customers

      - name: Show Running
        run: docker ps

      - name: Prepare JMeter Test Files
        run: |
          mkdir -p tests
          # Copy your JMX file to the tests directory
          cp ms-example-usage/jmeter-tests.jmx tests/
          # Copy your CSV file to the tests directory
          cp ms-example-usage/customers.csv tests/

      - name: Add Delay Before JMeter Tests
        run: sleep 30

      - name: Run JMeter Tests
        uses: rbhadti94/apache-jmeter-action@v0.5.0
        with:
          testFilePath: tests/jmeter-tests.jmx
          outputReportsFolder: reports/
          args: "--loglevel INFO"
          
      - name: Archive JMeter Test Reports
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-test-results
          path: reports/
          retention-days: 7

      # Optional: Fail the workflow if JMeter tests fail
      - name: Check JMeter Test Results
        run: |
          # This is a simple example. You might want to add more sophisticated
          # error checking based on JMeter's output
          if [ -z "$(ls -A reports/)" ]; then
            echo "No JMeter reports found"
            exit 1
          fi
      - name: Docker Compose Down
        working-directory: ms-example-usage
        run: docker compose down
